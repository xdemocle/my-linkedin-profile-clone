# Architecture Decisions

Rationale behind key architectural choices in this project.

## JSON Resume Schema as Source of Truth

**Decision:** Use JSON Resume schema (`src/data/resume-{locale}.json`) as the primary data source for all resume/profile information.

**Why:**

- **Standardized Format**: JSON Resume is an industry standard, making data portable and reusable
- **Multi-Language Support**: Easy to maintain separate locale files with identical structure
- **Separation of Concerns**: Resume data separate from UI translations
- **Future-Proof**: Can export/import resume data from other tools (LinkedIn, Notion, etc.)
- **Type Safety**: Clear schema definition enables TypeScript validation

**Trade-offs:**

- Requires adapter hook (`useJSONResumeAdapter`) to map to component-specific types
- Two separate systems: JSON Resume data + translation messages

**Related Files:**

- `src/data/resume-{locale}.json` - Data storage
- `src/hooks/useJSONResumeAdapter.ts` - Mapping logic
- `src/types/json-resume.ts` - Schema types

---

## Multi-Language Data Structure

**Decision:** Maintain separate `resume-{locale}.json` files for each language rather than a single file with nested language objects.

**Why:**

- **Clarity**: Each file is self-contained and easy to understand
- **Translation Workflow**: Translators work on individual files without nested complexity
- **Locale-Specific Variations**: Can have different project descriptions per language
- **Consistency**: Mirrors message file structure (`src/messages/{locale}.json`)

**Structure:**

```
src/data/
├── resume-en.json    (English)
├── resume-it.json    (Italian)
├── resume-fr.json    (French)
├── resume-es.json    (Spanish)
└── resume-ar.json    (Arabic)
```

**Related Files:**

- `src/hooks/useJSONResumeAdapter.ts` - Loads correct locale file based on current language

---

## Prerendering for Static Site Generation

**Decision:** Use `vite-prerender-plugin` to generate 49 static HTML files at build time instead of pure SPA.

**Why:**

- **SEO Benefits**: Static HTML with meta tags, structured data, hreflang tags
- **Performance**: No client-side routing delay, instant page loads
- **Deployment**: Works perfectly on Cloudflare Pages without server
- **Offline Support**: Prerendered pages work without JavaScript
- **Caching**: Static files cache efficiently on CDN

**Trade-offs:**

- Build time increases (7-8 seconds)
- Dynamic content requires rebuild
- Client-side SPA navigation still works for better UX after initial load

**Routes Prerendered:**

- 5 languages × (1 home + 4 pages) = 20 routes
- Plus 29 alias routes = 49 total pages

**Related Files:**

- `vite.config.ts` - Prerender configuration
- `src/main.tsx` - Prerender function
- `src/lib/seo-meta.ts` - SEO generation during build

---

## Component Architecture: shadcn/ui + Custom Wrappers

**Decision:** Use shadcn/ui components as base layer with custom wrapper components for project-specific needs.

**Why:**

- **Consistency**: shadcn/ui ensures design system coherence
- **Accessibility**: Radix UI primitives provide WCAG compliance
- **Customization**: Easy to wrap and extend with project-specific logic
- **Maintainability**: Updates to shadcn/ui components propagate automatically
- **Type Safety**: Full TypeScript support

**Pattern:**

```
shadcn/ui (Radix UI primitives)
    ↓
Custom Wrapper Components (e.g., Card, Button with project defaults)
    ↓
Feature Components (e.g., ProfileHeader, ExperienceSection)
```

**Related Files:**

- `src/components/ui/` - shadcn/ui components
- `src/components/profile/` - Feature components
- `src/components/layout/` - Layout components

---

## State Management: Context API + Custom Hooks

**Decision:** Use React Context API for global state (locale, layout size, search) with custom hooks for data adaptation.

**Why:**

- **Simplicity**: No external state management library needed
- **Built-in**: React's native solution, no dependencies
- **Performance**: Fine-grained context splitting prevents unnecessary re-renders
- **Hooks Pattern**: Aligns with modern React practices

**Context Hierarchy:**

```
AppContext (global app state)
├── isSearchOpen
├── isMenuOpen
├── isLayoutLarge (with localStorage persistence)
├── searchQuery
└── navLinks, socialLinks

LocaleContext (language/i18n state)
├── locale
├── messages
└── setLocale
```

**Related Files:**

- `src/contexts/AppContext.tsx` - Context definition
- `src/contexts/AppContextProvider.tsx` - Provider with state logic
- `src/hooks/useApp.ts` - Hook for consuming AppContext
- `src/hooks/useLocale.ts` - Hook for consuming LocaleContext

---

## Internationalization (i18n) Strategy

**Decision:** Use `use-intl` library with separate message files per locale and JSON Resume data files per locale.

**Why:**

- **Dual-Layer Approach**:
  - Message files for UI text (translations)
  - JSON Resume files for content data (resume information)
- **Flexibility**: UI can be translated independently from content
- **Scalability**: Easy to add new languages
- **Consistency**: All 5 languages use identical structure

**Language Support:**

- English (en) - Default
- Italian (it)
- French (fr)
- Spanish (es)
- Arabic (ar) - RTL support

**Message File Structure:**

```json
{
  "Navigation": { ... },
  "Common": { ... },
  "ProfileData": { ... },
  "Skills": { ... },
  ...
}
```

**Related Files:**

- `src/messages/{locale}.json` - UI translations
- `src/data/resume-{locale}.json` - Content data
- `src/hooks/useLocale.ts` - Locale context hook
- `src/lib/i18n.ts` - URL locale detection

---

## Layout Constraint Strategy

**Decision:** Always apply `max-w-7xl` in HTML, use CSS to override when layout-large is enabled.

**Why:**

- **Simplicity**: No conditional React logic needed
- **Performance**: CSS changes are instant, no React re-render needed
- **Persistence**: Works with localStorage preference without flash
- **Maintainability**: Single source of truth in CSS

**Implementation:**

```css
/* Default: constrained layout */
main,
header > div {
  /* inherits max-w-7xl from Tailwind */
}

/* Override: full-width layout */
html.layout-large main,
html.layout-large header > div {
  max-width: none !important;
}
```

**Related Files:**

- `src/index.css` - CSS override rule
- `src/components/layout/Navbar.tsx` - Always includes max-w-7xl
- `src/components/layout/PageLayout.tsx` - Always includes max-w-7xl
- `src/contexts/AppContextProvider.tsx` - Manages layout-large class

---

## Sidebar Scrolling Strategy

**Decision:** Enable sticky scrolling for pages with ≤2 sidebar blocks, disable for pages with 3+ blocks.

**Why:**

- **UX**: Sticky scrolling works well with limited sidebar content
- **Content-Heavy Pages**: Disabling prevents awkward scrolling on content-rich sidebars
- **Flexibility**: Per-page configuration via `disableSidebarScroll` prop

**Pages Configuration:**

- **Scrolling Enabled**: SkillsPage, RecommendationsPage (2 blocks each)
- **Scrolling Disabled**: MainPage, ExperiencePage (3 blocks each)

**Implementation:**

```tsx
<PageLayout disableSidebarScroll>{/* Sidebar won't scroll */}</PageLayout>
```

**Related Files:**

- `src/components/layout/PageLayout.tsx` - Conditional scroll classes
- `src/pages/MainPage.tsx` - Disables scrolling
- `src/pages/ExperiencePage.tsx` - Disables scrolling

---

## Responsive Design: Mobile-First Approach

**Decision:** Build mobile layouts first, then enhance for larger screens using Tailwind breakpoints.

**Why:**

- **Progressive Enhancement**: Core functionality works on all devices
- **Performance**: Mobile users get minimal CSS
- **Accessibility**: Touch targets are properly sized (44px+)
- **Maintainability**: Simpler to add features than remove them

**Breakpoints Used:**

- `xs` (default) - Mobile
- `sm` - Small tablets
- `md` - Tablets
- `lg` - Desktops
- `xl` - Large desktops

**Related Files:**

- All component files use Tailwind responsive classes
- `tailwind.config.ts` - Breakpoint configuration

---

## Error Handling Strategy

**Decision:** Use ErrorBoundary component to catch React errors with graceful fallback UI.

**Why:**

- **Resilience**: Prevents entire app from crashing on component errors
- **User Experience**: Shows helpful error message instead of blank page
- **Development**: Easier to debug component-specific issues
- **Translation**: Error messages are properly internationalized

**Related Files:**

- `src/components/ErrorBoundary.tsx` - Error boundary implementation
- `src/components/layout/PageLayout.tsx` - Wraps main content sections

---

## Asset Management

**Decision:** Use local PNG assets from `public/assets/` instead of external URLs.

**Why:**

- **Performance**: No external HTTP requests
- **Reliability**: Assets don't depend on external services
- **Build Verification**: Assets are included in build process
- **Consistency**: Guaranteed availability across all environments

**Asset Organization:**

```
public/assets/
├── ico/          - Favicon and icons
├── png/          - Company logos, avatars
├── images/       - General images
└── css/          - Custom stylesheets
```

**Related Files:**

- `public/assets/` - Asset storage
- `src/pages/ExperiencePage.tsx` - Uses company logos
- `src/components/profile/ProfileHeader.tsx` - Uses avatar

---

## Build Output Structure

**Decision:** Output to `dist/client/` for Cloudflare Pages compatibility.

**Why:**

- **Cloudflare Pages**: Expects client-side build output in specific directory
- **Prerendering**: Vite outputs prerendered pages to this location
- **Deployment**: Wrangler configuration points to this directory

**Output Structure:**

```
dist/client/
├── index.html          - Home page (English)
├── en/                 - English routes
├── it/, fr/, es/, ar/  - Other language routes
└── assets/             - Built JavaScript, CSS, images
```

**Related Files:**

- `vite.config.ts` - Output configuration
- `wrangler.jsonc` - Deployment configuration
